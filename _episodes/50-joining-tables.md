---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 50-joining-tables.md in _episodes_rmd/
source: Rmd
title: "Joining tables"
teaching: XX
exercises: XX
questions:
- "Join tables in R"
objectives:
- Understand the need and concept of table joins
- Understand the different types of joins
- Understand the importance of keys in joins and the implications of using non-unique keys
keypoints:
- "Join tables of data in R"
---



## Joining tables

In many real life situations, data are spread across multiple tables.
Usually this occurs because different types of information about a subject,
e.g. a patient, are collected from different sources.

It may be desirable for some analyses to combine
data from two or more tables into a single data frame based on a
column that would be common to all the tables, for example, an attribute that
uniquely identifies the subjects.

The `dplyr` package provides a set of join functions for combining
two data frames based on matches within specified columns.

For further reading, please refer to the chapter about [table
joins](https://r4ds.had.co.nz/relational-data.html#understanding-joins)
in [R for Data Science](https://r4ds.had.co.nz/).

The [Data Transformation Cheat
Sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)
also provides a short overview on table joins.


## Combining tables

We are going to illustrate join using a common example from the
bioinformatics world, where annotations about genes are scattered in
different tables that have one or more shared columns.

The data we are going to use are available in the following package.


~~~
# install.packages(c("BiocManager", "remotes"))
# BiocManager::install("UCLouvain-CBIO/rWSBIM1207")
library("rWSBIM1207")
~~~
{: .language-r}



~~~
Error in library("rWSBIM1207"): there is no package called 'rWSBIM1207'
~~~
{: .error}



~~~
data(jdf)
~~~
{: .language-r}



~~~
Warning in data(jdf): data set 'jdf' not found
~~~
{: .warning}

The data is composed of several tables.

The first table, `jdf1`, contains protein [UniProt](https://www.uniprot.org/)[^up] unique
accession number (`uniprot` variable), the most likely sub-cellular
localisation of these respective proteins (`organelle` variable) as
well as the proteins identifier (`entry`).

[^up]: UniProt is the protein information database. Its mission is to *provide the scientific community with a comprehensive, high-quality and freely accessible resource of protein sequence and functional information*.


~~~
jdf1
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf1' not found
~~~
{: .error}

The second table, `jdf2`, contains the name of the gene that codes for the
protein (`gene_name` variable), a description of the gene
(`description` variable), the uniprot accession number (this is the
common variable that can be used to join tables) and the species the
protein information comes from (`organism` variable).


~~~
jdf2
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf2' not found
~~~
{: .error}

We now want to join these two tables into a single one containing all
variables.

We are going to use the `full_join` function of `dplyr` to do
so,

Th function will automatically find the common variable (in this case `uniprot`)
to match observations from the first and second table.


~~~
library("dplyr")
~~~
{: .language-r}



~~~

Attaching package: 'dplyr'
~~~
{: .output}



~~~
The following objects are masked from 'package:stats':

    filter, lag
~~~
{: .output}



~~~
The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union
~~~
{: .output}



~~~
full_join(jdf1, jdf2)
~~~
{: .language-r}



~~~
Error in full_join(jdf1, jdf2): object 'jdf1' not found
~~~
{: .error}

In these examples, each observation of the `jdf1` and `jdf2`
tables are uniquely identified by their UniProt accession number. Such
variables are called **keys**. Keys are used to match observations
across different tables.

Now let's look at a third table, `jdf3`. It also contains the column uniProt,
but it is written differently!


~~~
jdf3
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf3' not found
~~~
{: .error}

In case none of the variable names match, we can set manually the variables to
use for the matching. These variables can be set using the `by` argument,
as shown below with the `jdf1` (as
above) and `jdf3` tables, where the UniProt accession number is
encoded using a different capitalisation.


~~~
names(jdf3)
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf3' not found
~~~
{: .error}



~~~
full_join(jdf1, jdf3, by = c("uniprot" = "UniProt"))
~~~
{: .language-r}



~~~
Error in full_join(jdf1, jdf3, by = c(uniprot = "UniProt")): object 'jdf1' not found
~~~
{: .error}

As can be seen above, the variable name of the first table is retained
in the joined one.

> ## Challenge
> Using the `full_join` function, join tables `jdf4`
> and `jdf5`. What has happened for observations `P26039` and `P02468`?
>
> > ## Solution
> >
> > 
> > ~~~
> > full_join(jdf4, jdf5)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in full_join(jdf4, jdf5): object 'jdf4' not found
> > ~~~
> > {: .error}
> >
> > `P26039` and `P02468` are only present in `jdf4` and `jdf5`
> > respectively, and their respective values for the variables of the
> > table have been encoded as missing.
> >
> {: .solution}
{: .challenge}

## Different types of joins

Above, we have used the `full_join` function, that fully joins two
tables and keeps all observations, adding missing values if
necessary. Sometimes, we want to be selective, and keep observations
that are present in only one or both tables.

- An **inner join** keeps observations that are present in both
  tables.


~~~
Error in knitr::include_graphics("./figs/join-inner.png"): Cannot find the file(s): "./figs/join-inner.png"
~~~
{: .error}

- A **left join** keeps observations that are present in the left
  (first) table, dropping those that are only present in the other.
- A **right join** keeps observations that are present in the right
  (second) table, dropping those that are only present in the other.
- A **full join** keeps all observations.



~~~
Error in knitr::include_graphics("./figs/join-outer.png"): Cannot find the file(s): "./figs/join-outer.png"
~~~
{: .error}

> ## Challenge
> Join tables `jdf4` and `jdf5`, keeping only observations in `jdf4`.
>
> > ## Solution
> > 
> > ~~~
> > left_join(jdf4, jdf5)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in left_join(jdf4, jdf5): object 'jdf4' not found
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}

> ## Challenge
> Join tables `jdf4` and `jdf5`, keeping only observations in `jdf5`.
>
> > ## Solution
> > 
> > ~~~
> > right_join(jdf4, jdf5)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in right_join(jdf4, jdf5): object 'jdf4' not found
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}

> ## Challenge
> Join tables `jdf4` and `jdf5`, keeping observations observed in both tables.
>
> > ## Solution
> > 
> > ~~~
> > inner_join(jdf4, jdf5)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in inner_join(jdf4, jdf5): object 'jdf4' not found
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}

## Multiple matches

Sometimes, keys aren't unique.

In the `jdf6` table below, we see that the accession number `Q99PL5` is repeated
twice. According to this table, the ribosomial protein binding protein 1 localises in the
endoplasmic reticulum and in the Golgi apparatus.


~~~
jdf6
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf6' not found
~~~
{: .error}

If we now want to join `jdf6` and `jdf2`, the variables of the latter
will be duplicated.


~~~
inner_join(jdf6, jdf2)
~~~
{: .language-r}



~~~
Error in inner_join(jdf6, jdf2): object 'jdf6' not found
~~~
{: .error}

In the case above, repeating is useful, as it completes `jdf6` with
correct information from `jdf2`.

But one needs however to be careful when duplicated keys exist in both tables.

Let's now use jdf7 for the join. It also has 2 entries for the uniprot `Q99PL5`

~~~
jdf7
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf7' not found
~~~
{: .error}


Let's we create an inner join between `jdf6` and `jdf7` (both having duplicated `Q99PL5` entries)


~~~
inner_join(jdf6, jdf7)
~~~
{: .language-r}



~~~
Error in inner_join(jdf6, jdf7): object 'jdf6' not found
~~~
{: .error}

> ## Challenge
> Interpret the result of the inner join above, where both tables have duplicated keys.
>
> > ## Solution
> >
> > `jdf6` has two entries, one for each possible sub-cellular
> > localisation of the protein. `jdf7` has also two entries, referring to
> > two different quantitative measurements (variable `measure`). When
> > joining the duplicated keys, you get all possible combinations.
> >
> > 
> > ~~~
> > Error in knitr::include_graphics("./figs/join-many-to-many.png"): Cannot find the file(s): "./figs/join-many-to-many.png"
> > ~~~
> > {: .error}
> >
> > In this case, we obtain wrong information: both proteins in the ER and
> > in the GA both have value 102 and 3.
> >
> > 
> > ~~~
> > inner_join(jdf6, jdf7)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in inner_join(jdf6, jdf7): object 'jdf6' not found
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}


## Matching across multiple keys

So far, we have matched tables using a single key (possibly with
different names in the two tables). Sometimes, it is necessary to
match tables using multiple keys. A typical example is when multiple
variables are needed to discriminate different rows in a tables.

Following up from the last example, we see that the duplicated UniProt
accession numbers in the `jdf6` and `jdf7` tables refer to different
isoforms of the same RRBP1 gene.


~~~
jdf6
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf6' not found
~~~
{: .error}


~~~
jdf7
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'jdf7' not found
~~~
{: .error}


To uniquely identify isoforms, we should consider two keys:

- the UniProt accession number (named `uniprot` in both tables)

- and the isoform number (called `isoform` and `isoform_num` respectively)

Because the isoform status was encoded using different names
(which is, of course a source of confusion), `jdf6` and `jdf7` are
only automatically joined based on the shared `uniprot` key.

If the isoform status was encoded the same way in both tables, the join would
have been automatically done on both keys!


Here, we need to join using both keys and need to explicitly name the variables
used for the join.



~~~
inner_join(jdf6, jdf7, by = c("uniprot" = "uniprot", "isoform" = "isoform_num"))
~~~
{: .language-r}



~~~
Error in inner_join(jdf6, jdf7, by = c(uniprot = "uniprot", isoform = "isoform_num")): object 'jdf6' not found
~~~
{: .error}

We now see that isoform 1 localised to the ER and has a measured value
of 102, while isoform 2, that localised to the GA, has a measured
value of 3.

Ideally, the isoform variables should be named identically in the two
tables to enable an automatic join with the two keys.

An alternative could be to rename the `isoform_num` from jdf7 in order to
have the both keys names present in both tables, enabling an automatic join.
This can be done easily using the rename function from `dplyr` package.


~~~
jdf7 %>% rename(isoform = isoform_num)
~~~
{: .language-r}



~~~
Error in rename(., isoform = isoform_num): object 'jdf7' not found
~~~
{: .error}



~~~
inner_join(jdf6,
           jdf7 %>%
             rename(isoform = isoform_num))
~~~
{: .language-r}



~~~
Error in inner_join(jdf6, jdf7 %>% rename(isoform = isoform_num)): object 'jdf6' not found
~~~
{: .error}



## Row and column binding

There are two other important functions in R, `rbind` and `cbind`,
that can be used to combine two dataframes.



- `cbind` can be used to bind two data frames by columns, but both must have the same
number of rows.


~~~
d2
~~~
{: .language-r}



~~~
  a b
1 4 4
2 5 5
~~~
{: .output}



~~~
d3
~~~
{: .language-r}



~~~
  v1 v2 v3
1  1  3  5
2  2  4  6
~~~
{: .output}



~~~
cbind(d2, d3)
~~~
{: .language-r}



~~~
  a b v1 v2 v3
1 4 4  1  3  5
2 5 5  2  4  6
~~~
{: .output}


- `rbind`, can be used to bind two data frames by rows, but both must have
the same number of columns, and the same column names!


~~~
d1
~~~
{: .language-r}



~~~
  x y
1 1 1
2 2 2
3 3 3
~~~
{: .output}



~~~
d2
~~~
{: .language-r}



~~~
  a b
1 4 4
2 5 5
~~~
{: .output}


using `rbind(d1, d2)` would produce an error because both data frames do not have the
same column names (even if they have the same number of columns)

If we change the names of d2, it works!


~~~
names(d2) <- names(d1)
d1
~~~
{: .language-r}



~~~
  x y
1 1 1
2 2 2
3 3 3
~~~
{: .output}



~~~
d2
~~~
{: .language-r}



~~~
  x y
1 4 4
2 5 5
~~~
{: .output}



~~~
rbind(d1, d2)
~~~
{: .language-r}



~~~
  x y
1 1 1
2 2 2
3 3 3
4 4 4
5 5 5
~~~
{: .output}

Note that beyond the dimensions and column names that are required to
match, the real meaning of `rbind` is to bind data frames that contain
observations for the same set of variables - there is more than only
the column names!




**Note**: `rbind` and `cbind` are base R functions. The *tidyverse*
alternatives from the `dplyr` package are `bind_rows` and `bind_cols`
and work similarly.
